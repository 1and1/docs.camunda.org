<h1 id="process-applications">Process Applications</h1>

A Process Application is an ordinary Java Application that uses the camunda process engine for BPM and Worklow functionality. Most such applications will start their own process engine (or use a process engine provided by the runtime container), deploy some BPMN 2.0 process definitions and interact with process instances derived from these process definitions. Since most process applications perform very similar bootstrapping, deployment and runtime tasks, we generalized this functionaly into a Java Class which is named - *Surprise!* - `ProcessApplication`. The concept is similar to the `javax.ws.rs.core.Application` class in JAX-RS: adding the process application class allows you to bootrap and configure the provided services.

Adding a `ProcessApplication` class to your Java Application provides your applications with the following services:

  * **Bootrapping** embedded process engine(s) or looking up container managed process engine(s). You can define multiple process engines in a file named `processes.xml` which is added to your application. The ProcessApplication class makes sure this file is picked up and the defined process engines are started and stopped as the application is deployed / undeployed.
  * **Automatic deployment** of classpath BPMN 2.0 resources. You can define multiple deployments (process archives) in the `processes.xml` file. The process application class makes sure the deployments are performed upon deployment of your application. Scanning your application for process definition resource files (engine in *.bpmn20.xml or *.bpmn) is supported as well.
  * **Resolution of application-local Java Delegate Implementations** and Beans in case of a multi-application deployment. The process application class allows your java application to expose your local Java Delegate implementations or Spring / CDI beans to a shared, container managed process engine. This way you can start a single process engine that dispatches to multiple process applications that can be (re-)deployed independently.

Transforming an existing Java Application into a Process Application is easy and non-intrusive. You simply have to add:

* A Process Application class: The Process Application class constitutes the interface between your application and the process engine. There are different base classes you can extent to reflect different environments (e.g. Servlet vs. EJB Container).
* A processes.xml file to META-INF: The deployment descriptor file allows  to provide a declarative configuration of the deployment(s) this process application makes to the process engine. It can be empty and serve as simple marker file - but it must be present.

<div class="alert">
  <p>
    <strong>Heads-up!</strong>
    You might want to checkout the <a href="http://www.camunda.org/">Getting Started Tutorial</a> first as it explaines the creation of a process application step by step.
  </p>
</div>

<h2 id="the-process-application-class">The Process Application class</h2>

You can deleagte the bootstrapping of the process engine and process deployment to a process application class. The basic ProcessApplication functionality is provided by the `org.camunda.bpm.application.AbstractProcessApplication` base class. Based on this class there is a set of environment-specific sub classes that realize integration within a specific environment:

* **ServletProcessApplication**: To be used for Process Applications is a Servlet Container like Apache Tomcat.
* **EjbProcessApplication**: To be used in a Java EE application server like JBoss, Glassfish or WebSphere Application Server.
* **EmbeddedProcessApplication**: To be used when embedding the process engine is an ordinary Java SE application.
* **SpringProcessApplication**: To be used for bootstrapping the process application from a Spring Application Context.

In the following, we walk through the different implementations and discuss where and how they can be used.

<h3 id="the-servlet-process-application">The ServletProcessApplication</h3>
<div class="alert">
  <p>
    <strong>All Servlet Containers</strong>
  </p>
    <span class="container-tiny tomcat"></span>
    <span class="container-tiny as7"></span>
    <span class="container-tiny glassfish"></span>

  <p>The Servlet Process Application is supported on all containers. Read the <a href="#servlet-process-applicarion-inside-ejb-container">note about Servlet Process Application and EJB / Java EE containers</a>.</p>
  <p><strong>Packaging</strong>: WAR (or embedded WAR inside EAR)</p>
</div>

The `ServletProcessApplication` class is the base class for developing Process Applications based on the Servlet Specification (Java Web Applications). The servlet process application implements the `javax.servlet.ServletContextListener` interface which allows it to participate in the deployment lifecycle of your Web application

The following is an example of a Servlet Process Application:

    package org.camunda.bpm.example.loanapproval;

    import org.camunda.bpm.application.ProcessApplication;
    import org.camunda.bpm.application.impl.ServletProcessApplication;

    @ProcessApplication("Loan Approval App")
    public class LoanApprovalApplication extends ServletProcessApplication {
      // empty implementation
    }

Notice the `@ProcessApplication` annotation. This annotation fulfills two purposes:

  * **providing the name of the ProcessApplication**: You can provide a custom name for you process application using the annotation: `@ProcessApplication("Loan Approval App")`. If no name is provided, a name is automatically detected. In case of a ServletProcessApplication, the name of the ServletContext is used.
  * **triggering auto-deployment**. In a Servlet 3.0 container, the annotation is sufficient for making sure that the process application is automatically picked up by the servlet container and automatically added as a ServletContextListener to the Servlet Container deployment. This functionality is realized by a `javax.servlet.ServletContainerInitializer` implementation named `org.camunda.bpm.application.impl.ServletProcessApplicationDeployer` which is located in the camunda-engine module. The implementation works for both embedded deployment of the camunda-engine.jar as a web application library in the `WEB-INF/lib` folder of your WAR file or for the deployment of the camunda-engine.jar as a shared library in the shared library (i.e. Apache Tomcat global `lib/` folder) directory of your application server. The Servlet 3.0 Specification foresees both deployment scenarios. In case of embedded deployment, the `ServletProcessApplicationDeployer` is notified once, when the webapplication is deployed. In case of deployment as a shared library, the `ServletProcessApplicationDeployer` is notified for each WAR file containing a class annotated with `@ProcessApplication` (as required by the Servlet 3.0 Specification).

This means that in case you deploy to a Servlet 3.0 compliant container (such as Apache Tomcat 7) annotating your class with `@ProcessApplication` is sufficient.

#### Deploying to Apache Tomcat 6 or other Pre-Servlet 3.0 Containers

In a Pre-Servlet 3.0 container such as Apache Tomcat 6 (or JBoss Application Server 5 for that matter), you need manually register your ProcessApplication class as Servlet Context Listener in the Servlet Container. This can be achieved by adding a listener element to your `WEB-INF/web.xml` file:


    <?xml version="1.0" encoding="UTF-8"?>
    <web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

      <listener>
        <listener-class>org.my.project.MyProcessApplication</listener-class>
      </listener>

    </web-app>

<a name="servlet-process-applicarion-inside-ejb-container"></a>
#### Using the ServletProcessApplication inside an EJB / Java EE Container such as Glassfish or JBoss

You can use the ServletProcessApplication inside an EJB / Java EE Container such as Glassfish or JBoss. Process application bootstrapping and deployment will work in the same way. However, you will not be able to use all Java EE features at runtime. In contrast to the `EjbProcessApplication` (see next section), the `ServletProcessApplication` does not perform proper Java EE cross-application context switching. When the process engine invokes Java Delegates form your application, only the Context Class Loader of the current Thread is set to the classloader of your application. This does allow the process engine to resolve Java Deleagte implementations form your application but the container will not perform an EE context switch to your application. As a consequence, if you use the ServletProcessApplciation inside a Java EE container, you will not be able to use features like:

  * using CDI beans and EJBs as JavaDelegate Implementations in combination with the Job Executor,
  * using @RequestScoped CDI Beans with the Job Executor,
  * looking up JNDI resources from the application's naming scope

If your application does not use such features, it is perfectly fine using the ServletProcessApplication inside an EE container in that case you only get servlet specification guarantees.

<h3 id="the-ejb-process-application">The EjbProcessApplication</h3>
<div class="alert ">
  <p>
    <strong>Java EE 6 Container only</strong>
  </p>
  <p>
    <span class="container-tiny as7"></span>
    <span class="container-tiny glassfish"></span>
  </p>
  <p>The EjbProcessApplication is supported in Java EE 6 containers or better. It is not supported on Servlet Containers like Apache Tomcat. It may be adapted to work inside Java EE 5 Containers.</p>
  <p><strong>Packaging:</strong> JAR, WAR, EAR</p>
</div>

The EjbProcessApplication is the base class for developing Java EE based Process Applications. An Ejb Process Application class itself must be deployed as an EJB.

In order to add an Ejb Process Application to your Java Application, you have two options:

  * **Bundling the camunda-ejb-client**: we provide a generic, reusable EjbProcessApplication implementation (named `org.camunda.bpm.application.impl.ejb.DefaultEjbProcessApplication`) bundled as a maven artifact. This simplest possibility is to add this implementation as a maven dependency to your application.
  * **Writing a custom EjbProcessApplication**: if you want to customize the behavior of the EjbProcessApplication, you can write a custom subclass of the EjbProcessApplication class and add it to your application.

Both options are explained in greater detail below.

#### Bundling the camunda-ejb-client Jar

The most convenient option for deploying a process application to an Ejb Container is adding the following maven dependency to you maven project:

    <dependency>
      <groupId>org.camunda.bpm.javaee</groupId>
      <artifactId>camunda-ejb-client</artifactId>
      <version>${camunda.version}</version>
    </dependency>

The camunda-ejb-client contains a reusable default implemenation of the EjbProcessApplicaiton as a Singleton Session Bean with auto-activation.

This deployment option requires that your project is a composite deployment (such as a WAR or EAR) deployment since you need to add a library JAR file. You could of course use something like the maven shade plugin for adding the class contained in the camunda-ejb-client artifact to a JAR-based deployment.

<div class="alert alert-info">
  We always recommend using the camunda-ejb-client over deploying a custom EjbProcessApplication class unless you want to customize the behavior of the EjbProcessApplication.
</div>

#### Deploying a custom EjbProcessApplication class

If you want to customize the behavior of the the EjbProcessApplication class you have to option of writing a custom EjbProcessApplication class. The following is an example of such an implementation:

    @Singleton
    @Startup
    @ConcurrencyManagement(ConcurrencyManagementType.BEAN)
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    @ProcessApplication
    @Local(ProcessApplicationInterface.class)
    public class MyEjbProcessApplication extends EjbProcessApplication {

      @PostConstruct
      public void start() {
        deploy();
      }

      @PreDestroy
      public void stop() {
        undeploy();
      }

    }

#### Invocation Semantics of  the EjbProcessApplication

The fact that the EjbProcessApplication exposes itself as a Session Bean Component inside the EJB container

 * determines the invocation semantics when invoking code from the process application and
 * the nature of the `ProcessApplicationReference` held by the process engine.

When the process engine invokes the Ejb Process Application, it gets EJB invocation semantics. For example, if your process application provides a `JavaDelegate` implementation, the process engine will call the EjbProcessApplication's `execute(java.util.concurrent.Callable)` method and from that method invoke `JavaDelegate`. This makes sure that

  * the call is intercepted by the EJB container and "enters" the process application legally.
  * the `JavaDelegate` may take advantage of the EjbProcessApplication's invocation context and resolve resources from the component's environment (such as a `java:comp/BeanManager`).

<pre>
                   Big pile of EJB interceptors
                                |
                                |  +--------------------+
                                |  |Process Application |
                  invoke        v  |                    |
 ProcessEngine ----------------OOOOO--> Java Delegate   |
                                   |                    |
                                   |                    |
                                   +--------------------+
</pre>

When the EjbProcessApplication registers with a process engine (see `ManagementService#registerProcessApplication(String, ProcessApplicationReference)`, the process application passes a reference to itself to the process engine. This reference allows the process engine to reference the process application. The EjbProcessApplication takes advantage of the Ejb Containers naming context and passes a reference containing the EJBProcessApplication's Component Name to the process engine. Whenever the process engine needs access to process application, the actual component instance is looked up and invoked.

<h3 id="the-embedded-process-application">The EmbeddedProcessApplication</h3>
<div class="alert ">
  <p>
    <strong>All containers</strong>
  </p>
  <p>
    <span class="container-tiny jvm"></span>
    <span class="container-tiny tomcat"></span>
    <span class="container-tiny as7"></span>
    <span class="container-tiny glassfish"></span>
  </p>
  <p>The EmbeddedProcessApplication can only be used with an embedded process engine and does not provide
  auto-activation.</p>
  <p><strong>Packaging:</strong> JAR, WAR, EAR</p>
</div>

The `org.camunda.bpm.application.impl.EmbeddedProcessApplication` can only be used in combination with an embedded process engine. Usage in combination with a Shared Process Engine is not supported as the class performs no process application context switching at runtime.

The Embedded Process Application does also not provide auto-startup. You need to manually call the deploy method of your process application:

    // instantiate the process application
    MyProcessApplication processApplication = new MyProcessApplication();

    // deploy the process application
    processApplication.deploy();

    // interact with the process engine
    ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();
    processEngine.getRuntimeService().startProcessInstanceByKey(...);

    // undeploy the process application
    processApplication.undeploy();

Where the class `MyProcessApplication` could look like this:

    @ProcessApplication(
        name="my-app",
        deploymentDescriptors={"path/to/my/processes.xml"}
    )
    public class MyProcessApplication extends EmbeddedProcessApplication {

    }

<h3 id="the-spring-process-application">The SpringProcessApplication</h3>
<div class="alert ">
  <p>
    <strong>Supported on</strong>
  </p>
  <p>
    <span class="container-tiny jvm"></span>
    <span class="container-tiny tomcat"></span>
    <span class="container-tiny glassfish"></span>
  </p>
  <p>The spring process application is currently <strong>not supported on JBoss AS 7</strong>.</p>
  <p><strong>Packaging:</strong> JAR, WAR, EAR</p>
</div>

The `org.camunda.bpm.engine.spring.application.SpringProcessApplication` class allows bootstrapping a process application through a Spring Application Context. You can either reference the SpringProcessApplication class from an Xml-based application context configuration file or use annotation-based setup.

If your application is a WebApplicaiton you should use `org.camunda.bpm.engine.spring.application.SpringServletProcessApplication` as it provides support for exposing the servlet context path through the `ProcessApplicationInfo#PROP_SERVLET_CONTEXT_PATH` property.

<div class="alert alert-info">
  <strong>SpringServletProcessApplication</strong>
  <p>We recommend always using SpringServletProcessApplication unless the deployment is not a web application. Using this class requires the
  <code>org.springframework:spring-web</code> module to be on the classpath.</p>
</div>

#### Configuring a Spring Process Application

The following shows an example of how to bootstrap a SpringProcessApplication inside a spring application context Xml file:

    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                               http://www.springframework.org/schema/beans/spring-beans.xsd">

      <bean id="invoicePa" class="org.camunda.bpm.engine.spring.application.SpringServletProcessApplication" />

    </beans>

(Remember that you need a `META-INF/processes.xml` file, additionally).

##### Process Application Name

The SpringProcessApplication will use the bean name (`id="invoicePa"` in the example above) as auto-detected name for the process application. Make sure to provide a unique process application name here (unique across all process applications deployed on a single application server instance.) As an alternative, you can provide a custom subclass of SpringProcessApplication (or SpringServletProcessApplication) and override the `getName()` method.

#### Configuring a Managed Process Engine using Spring

If you use a Spring Process Application, you may want to configure your process engine inside the spring application context Xml file (as opposed to the processes.xml file). In this case, you must use the `org.camunda.bpm.engine.spring.container.ManagedProcessEngineFactoryBean` class for creating the process engine object instance. In addition to creating the process engine object, this implementation registers the process engine with the BPM Platform infrastructure such that the process engine is returned by the `ProcessEngineService`. The following is an example of how to configure a managed process engine using Spring.

    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                               http://www.springframework.org/schema/beans/spring-beans.xsd">

        <bean id="dataSource" class="org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy">
            <property name="targetDataSource">
                <bean class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
                    <property name="driverClass" value="org.h2.Driver"/>
                    <property name="url" value="jdbc:h2:mem:camunda;DB_CLOSE_DELAY=1000"/>
                    <property name="username" value="sa"/>
                    <property name="password" value=""/>
                </bean>
            </property>
        </bean>

        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource"/>
        </bean>

        <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration">
            <property name="processEngineName" value="default" />
            <property name="dataSource" ref="dataSource"/>
            <property name="transactionManager" ref="transactionManager"/>
            <property name="databaseSchemaUpdate" value="true"/>
            <property name="jobExecutorActivate" value="false"/>
        </bean>

        <!-- using ManagedProcessEngineFactoryBean allows registering the ProcessEngine with the BpmPlatform -->
        <bean id="processEngine" class="org.camunda.bpm.engine.spring.container.ManagedProcessEngineFactoryBean">
            <property name="processEngineConfiguration" ref="processEngineConfiguration"/>
        </bean>

        <bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService"/>
        <bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService"/>
        <bean id="taskService" factory-bean="processEngine" factory-method="getTaskService"/>
        <bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService"/>
        <bean id="managementService" factory-bean="processEngine" factory-method="getManagementService"/>

    </beans>

<h2 id="the-processes-xml-deployment-descriptor">The processes.xml deployment descriptor</h2>

The processes.xml deployment descriptor contains the deployment metadata for a process application. The following example is a simple example of a `processes.xml` deployment descriptor:

    <process-application
      xmlns="http://www.camunda.org/schema/1.0/ProcessApplication"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

      <process-archive name="loan-approval">
        <process-engine>default</process-engine>
        <properties>
          <property name="isDeleteUponUndeploy">false</property>
          <property name="isScanForProcessDefinitions">true</property>
        </properties>
      </process-archive>

    </process-application>

A single deployment (process-archive) is declared. The process archive has the name *loan-approval* and is deployed to the process engine with the name *default*. Two additional properties are specified:

  * `isDeleteUponUndeploy`: this property controls whether the undeployment of the process application should entail that the process engine deployment is deleted from the database. The default setting is false. If this property is set to true, undeployment of the process application leads to the removal of the deplyoment (including process instances) from the database.
  * `isScanForProcessDefinitions`: if this property is set to true, the classpath of the process application is automatically scanned for process definition resources. Process definition resources must end in `.bpmn20.xml` or `.bpmn`.

See [Deployment Descriptor Reference](/api-references/deployment-descriptors/#!/descriptors/processes-xml) for complete documentation of the syntax of the `processes.xml` file.

<h3 id="empty-processes-xml">Empty processes.xml</h3>

The processes.xml may optionally be empty (left blank). In this case default values are used. The empty processes.xml corresponds to the following configuration:

    <process-application
      xmlns="http://www.camunda.org/schema/1.0/ProcessApplication"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

      <process-archive>
        <properties>
          <property name="isDeleteUponUndeploy">false</property>
          <property name="isScanForProcessDefinitions">true</property>
        </properties>
      </process-archive>

    </process-application>

The empty processes.xml will scan for process definitions and perform a single deployment to the default process engine.

<h3 id="processes-xml-location">Location of the processes.xml file</h3>

The default location of the processes.xml file is `META-INF/processes.xml`. The camunda BPM platform will parse and process all processes.xml files on the classpath of a process application. Composite process applications (WAR / EAR) may carry multiple subdeployments providing a META-INF/processes.xml file.

In an apache maven based project, add the the processes.xml file to the `src/main/resources/META-INF` folder.

<h3 id="processes-xml-custom-location">Custom location for the processes.xml file</h3>

If you want to specify a custom location for the processes.xml file, you need to use the `deploymentDescriptors` property of the `@ProcessApplication` annotation:

    @ProcessApplication(
        name="my-app",
        deploymentDescriptors={"path/to/my/processes.xml"}
    )
    public class MyProcessApp extends ServletProcessApplication {

    }

The provided path(s) must be resolvable through the `ClassLoader#getResourceAsStream(String)`-Method of the classloader returned  by the `AbstractProcessApplication#getProcessApplicationClassloader()` method of the process application.

Multiple distinct locations are supported.

<h3 id="processes-xml-configuring-process-engines">Configuring process engines in the processes.xml file</h3>

The processes.xml file can also be used for configuring one or multiple process engine(s). The following is an example of a configuration of a process engine inside a processes.xml file:

    <process-application
    xmlns="http://www.camunda.org/schema/1.0/ProcessApplication"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

      <process-engine name="my-engine">
        <configuration>org.camunda.bpm.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration</configuration>
      </process-engine>

      <process-archive name="loan-approval">
        <process-engine>my-engine</process-engine>
        <properties>
          <property name="isDeleteUponUndeploy">false</property>
          <property name="isScanForProcessDefinitions">true</property>
        </properties>
      </process-archive>

    </process-application>

The `<configuration>...</configuration>` property allows specifying the name of a process engine configuration class to be used when building the process engine.

<h3 id="bpmplatform-application-deployment">Process Application Deployment</h3>

When deploying a set of BPMN 2.0 files to the process engine, a process deployment is created. The process deployment is performed to the process engine database such that when the process engine is stopped and restarted, the process definitions can be restored from the database and execution can continue. When a process application performs a deployment, in addition to the database deployment, it will create a registration for this deployment with the process engine. This is illustrated in the following figure:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/process-application-deployment.png') %>"></img></center>

Deployment of the process application "invoice.war" is illustrated on the left hand side:

1. The process application "invoice.war" deploys the invoice.bpmn file to the process engine.
2. The process engine checks the database for a previous deployment. In this case, no such deployment exists. As a result, a new database deployment `deployment-1` is created for the process definition.
3. The process application is registered for the `deployment-1` and the registration is returned.

When the process application is undeployed, the registration for the deployment is removed (see right hand side of the illustration above). After the registration is cleared, the deployment is still present in the database.

The registration allows the process engine to load additional Java Classes and resources from the process application when execution the processes. In contrast to the database deployment which can be restored whenever the process engine is restarted, the registration of the process application is kept as in-memory state. This in-memory state is local to an individual cluster node, allowing us to undeploy or redeploy a process application on a particular cluster node without affecting the other nodes and without having to restart the process engine. If the Job Executor is deployment aware, job execution will also stop for jobs created by this process application. However, as a consequence, the registration also needs to be re-created when the application server is restarted. This happens automatically if the process application takes part in the application server deployment lifecycle. For instance, ServletProcessApplications are deployed as ServletContextListeners and when the servlet context is started, it creates the deployment and registration with the process engine. The redeployment process is illustrated in the next figure:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/process-application-redeployment.png') %>"></img></center>

(a) Left hand side: invoice.bpmn has not changed:

1. The process application "invoice.war" deploys the invoice.bpmn file to the process engine.
2. The process engine checks the database for a previous deployment. Since `deployment-1` is still present in the database, the process engine compares the xml content of the database deployment with the bpmn20.xml file from the process application. In this case, both xml documents are identical which means that the existing deployment can be resumed.
3. The process application is registered for the existing deployment `deployment-1`.

(b) Right hand side: invoice.bpmn has changed:

1. The process application "invoice.war" deploys the invoice.bpmn file to the process engine.
2. The process engine checks the database for a previous deployment. Since `deployment-1` is still present in the database, the process engine compares the xml content of the database deployment with the invoice.bpmn file from the process application. In this case, changes are detected which means that a new deployment must be created.
3. The process engine creates a new deployment `deployment-2`, containing the updated invoice.bpmn process.
3. The process application is registered for the new deployment `deployment-2` AND the existing deployment `deployment-1`.

The resuming of the previous deployment (deployment-1) is a feature called `resumePreviousVersions` and is activated by default. If you want to deactivate this feature, you have to set the property to `false` in processes.xml file:

    <process-application
    xmlns="http://www.camunda.org/schema/1.0/ProcessApplication"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

      <process-archive name="loan-approval">
        ...
        <properties>
          ...
          <property name="isResumePreviousVersions">false</property>
        </properties>
      </process-archive>

    </process-application>


<h2 id="bpmplatform-application-events">Process Application Event Listeners</h2>
The process engine supports defining two types of event listeners: [Task Event Listeners and Execution Event Listeners](/api-references/bpmn20/#!/concepts/listeners).
Task Event listeners allow to react to Task Events (Task are Created, Assigned, Completed). Execution Listeners allow to react to events fired as execution progresses to the diagram: Activities are Started, Ended and Transitions are being taken.

When using the Process Application API, the process engine makes sure that Events are delegated to the right Process Application. For example, assume there is a Process Application deployed as "invoice.war" which deploys a process definition named "invoice". The invoice process has a task named "archive invoice". The application "invoice.war" further provides a Java Class implementing the [ExecutionListener](/api-references/java/org/camunda/bpm/engine/delegate/ExecutionListener.html) interface and is configured to be invoked whenever the END event is fired on the "archive invoice" activity. The process engine makes sure that the event is delegated to the listener class located inside the process application:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/process-application-events.png') %>"></img></center>

On top of the Execution and Task Listeners which are [explicitly configured in the BPMN 2.0 Xml](/api-references/bpmn20/#!/concepts/listeners), the process application API supports defining a global ExecutionListener and a global TaskListener which are notified about *all events* happening in the processes deployed by a process application:

    @ProcessApplication
    public class InvoiceProcessApplication extends ServletProcessApplication {

      public TaskListener getTaskListener() {
        return new TaskListener() {
          public void notify(DelegateTask delegateTask) {
            // handle all Task Events from Invoice Process
          }
        };
      }

      public ExecutionListener getExecutionListener() {
        return new ExecutionListener() {
          public void notify(DelegateExecution execution) throws Exception {
            // handle all Execution Events from Invoice Process
          }
        };
      }
    }

In order to use the global Process Application Event Listeners, you need to activate the corresponding [Process Engine Plugin](#bpmplatform-engine-plugins):

    <process-engine name="default">
      ...
      <plugins>
        <plugin>
          <class>org.camunda.bpm.application.impl.event.ProcessApplicationEventListenerPlugin</class>
        </plugin>
      </plugins>
    </process-engine>

Note that the plugin is activated by default in the pre-packaged camunda BPM distributions.

The Process Application Event Listener interface is also a good place for adding the CdiEventListener bridge if you want to [use Cdi Events with in combination with the shared process engine](#cdi-receiving-process-events-process-application).