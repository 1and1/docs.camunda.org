<h1 id="process-engine">Process Engine</h1>

<h2 id="process-engine-bootstrapping">Process Engine Bootstrapping</h2>

There are two basic modes of the Process Engine:

* *Shared Process Engine:* A process engine that is provided by the bpm platform and may be shared between multiple process applications.
* *Embedded Process Engine:* A process engine that runs embedded in the application and is only used by that particular application.

See <a href="https://app.camunda.com/confluence/display/foxUserGuide/Architecture+Overview">Architecture Overview</a> for more details on the differences on this.

In order to configure and create a Process Engine you have different options:

* *Container managed Process Engine:* The container of your choice (e.g. Tomcat, JBoss, Glassfish or WebSphere) completly manages the Process Engine for you. Configuration is done in a container specific way, see Container Integration for details.
* *Application managed Process Engine:*
 * Create Process Engine via Java API: You can startup a Process Engine (shared or embedded) completly by plain Java code, more details below.
 * Create Process Engine using XML configuration: You can use an XML configuration (Spring) to configure and startup your Engine, more details below.
 * Create Process Engine using Spring: Spring can manage your Process Engine for you, see <a href="#programming-model-spring">Engine Startup via Spring</a> for details.

<h3 id="process-engine-configuration-bean">ProcessEngineConfiguration bean</h3>

The camunda engine uses the <a href="http://docs.camunda.org/api-references/java/?org/camunda/bpm/engine/ProcessEngineConfiguration.html">ProcessEngineConfiguration bean</a> to configure and construct a standalone Process Engine. There are multiple subclasses available that can be used to define the processEngineConfiguration. These classes represent different environments, and set defaults accordingly. It's a best practice to select the class the matches (the most) your environment, to minimalise the number of properties needed to configure the engine. The following classes are currently available:

* org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration: the process engine is used in a standalone way. The engine itself will take care of the transactions. By default, the database will only be checked when the engine boots (and an exception is thrown if there is no database schema or the schema version is incorrect).
* org.camunda.bpm.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration: this is a convenience class for unit testing purposes. The engine itself will take care of the transactions. An H2 in-memory database is used by default. The database will be created and dropped when the engine boots and shuts down. When using this, probably no additional configuration is needed (except when using for example the job executor or mail capabilities).
* org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration: To be used when the process engine is used in a Spring environment. See the Spring integration section for more information.
* org.camunda.bpm.engine.impl.cfg.JtaProcessEngineConfiguration: To be used when the engine runs in standalone mode, with JTA transactions.

<h3 id="bootstrap-a-process-engine-java-api">Bootstrap a Process Engine using Java API</h3>

You can completly configure the engine programatically by creating the right ProcessEngineConfiguration object or use some pre-defined one:

    ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();
    ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration();

Now you can call the buildProcessEngine() operation to create a Process Engine:

    ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration()
      .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE)
      .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000")
      .setJobExecutorActivate(true)
      .buildProcessEngine();

<h3 id="configure-process-engine-via-xml">Configure Process Engine via Spring XML</h3>

The easiest way to configure your Process Engine is via through an XML file called camunda.cfg.xml. Using that you can simply do:

    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine()

The camunda.cfg.xml must contain a bean that has the id 'processEngineConfiguration', select the best fitting ProcessEngineConfiguration class suiting your needs:

    <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration">

This will look for an camunda.cfg.xml file on the classpath and construct an engine based on the configuration in that file. The following snippet shows an example configuration:

    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd">

      <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration">

        <property name="jdbcUrl" value="jdbc:h2:mem:camunda;DB_CLOSE_DELAY=1000" />
        <property name="jdbcDriver" value="org.h2.Driver" />
        <property name="jdbcUsername" value="sa" />
        <property name="jdbcPassword" value="" />

        <property name="databaseSchemaUpdate" value="true" />

        <property name="jobExecutorActivate" value="false" />

        <property name="mailServerHost" value="mail.my-corp.com" />
        <property name="mailServerPort" value="5025" />
      </bean>

    </beans>

Note that the configuration XML is in fact a Spring configuration. This does not mean that the camunda engine can only be used in a Spring environment! We are simply leveraging the parsing and dependency injection capabilities of Spring internally for building up the engine.

The ProcessEngineConfiguration object can also be created programmatically using the configuration file. It is also possible to use a different bean id:

    ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();
    ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource);
    ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);
    ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream);
    ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName);

It is also possible not to use a configuration file, and create a configuration based on defaults (see the different supported classes for more information).

    ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();
    ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration();

All these `ProcessEngineConfiguration.createXXX()` methods return a ProcessEngineConfiguration that can further be tweaked if needed. After calling the `buildProcessEngine()` operation, a ProcessEngine is created as explained above.

<h3 id="configure-process-engine-bpm-platform-xml">Configure Process Engine in bpm-platform.xml</h3>

The [bpm-platform.xml](/api-references/deployment-descriptors/#!/descriptors/bpm-platform-xml) file is used to configure camunda BPM platform in the following distributions:

* Apache Tomcat
* Glassfish Application Server
* IBM Websphere Application Server

The `<process-engine ... />` xml tag allows defining a process engine:

    <?xml version="1.0" encoding="UTF-8"?>
    <bpm-platform xmlns="http://www.camunda.org/schema/1.0/BpmPlatform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.camunda.org/schema/1.0/BpmPlatform http://www.camunda.org/schema/1.0/BpmPlatform ">

      <job-executor>
        <job-acquisition name="default" />
      </job-executor>

      <process-engine name="default">
        <job-acquisition>default</job-acquisition>
        <configuration>org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration</configuration>
        <datasource>java:jdbc/ProcessEngine</datasource>

        <properties>
          <property name="history">full</property>
          <property name="databaseSchemaUpdate">true</property>
          <property name="authorizationEnabled">true</property>
        </properties>

      </process-engine>

    </bpm-platform>

See [Deployment Descriptor Reference](/api-references/deployment-descriptors/#!/descriptors/bpm-platform-xml) for complete documentation of the syntax of the `bpm-platform.xml` file.

<h3 id="configure-process-engine-processes-xml">Configure Process Engine in processes.xml</h3>

The process engine can also be configured and bootstrapped using the META-INF/processes.xml file. See [Section on processes.xml file](#processes-xml-configuring-process-engines) for details.

See [Deployment Descriptor Reference](/api-references/deployment-descriptors/#!/descriptors/processes-xml) for complete documentation of the syntax of the `processes.xml` file.

<h2 id="process-engine-api">Process Engine API</h2>

<h3 id="services-api">Services API</h3>

The Java API is the most common way of interacting with the engine. The central starting point is the ProcessEngine, which can be created in several ways as described in the configuration section. From the ProcessEngine, you can obtain the various services that contain the workflow/BPM methods. ProcessEngine and the services objects are thread safe. So you can keep a reference to 1 of those for a whole server.

<center><img class="img-responsive" src="<%= @docUrl('assets/img/implementation-java/api.services.png') %>"/></center>

    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

    RuntimeService runtimeService = processEngine.getRuntimeService();
    RepositoryService repositoryService = processEngine.getRepositoryService();
    TaskService taskService = processEngine.getTaskService();
    ManagementService managementService = processEngine.getManagementService();
    IdentityService identityService = processEngine.getIdentityService();
    HistoryService historyService = processEngine.getHistoryService();
    FormService formService = processEngine.getFormService();


`ProcessEngines.getDefaultProcessEngine()` will initialize and build a process engine the first time it is called and afterwards always return the same process engine. Proper creation and closing of all process engines can be done with `ProcessEngines.init()` and `ProcessEngines.destroy()`.

The ProcessEngines class will scan for all camunda.cfg.xml and activiti-context.xml files. For all `camunda.cfg.xml` files, the process engine will be built in the typical way: `ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()`. For all `activiti-context.xml` files, the process engine will be built in the Spring way: First the Spring application context is created and then the process engine is obtained from that application context.

All services are stateless. This means that you can easily run camunda BPM on multiple nodes in a cluster, each going to the same database, without having to worry about which machine actually executed previous calls. Any call to any service is idempotent regardless of where it is executed.

The **RepositoryService** is probably the first service needed when working with the camunda engine. This service offers operations for managing and manipulating deployments and process definitions. Without going into much detail here, a process definition is a Java counterpart of BPMN 2.0 process. It is a representation of the structure and behaviour of each of the steps of a process. A deployment is the unit of packaging within the engine. A deployment can contain multiple BPMN 2.0 xml files and any other resource. The choice of what is included in one deployment is up to the developer. It can range from a single process BPMN 2.0 xml file to a whole package of processes and relevant resources (for example the deployment 'hr-processes' could contain everything related to hr processes). The RepositoryService allows to deploy such packages. Deploying a deployment means it is uploaded to the engine, where all processes are inspected and parsed before being stored in the database. From that point on, the deployment is known to the system and any process included in the deployment can now be started.

Furthermore, this service allows to

* query on deployments and process definitions known to the engine.
* Suspend and activate process definitions. Suspending means no further operations can be done on them, while activation is the opposite operation.
* Retrieve various resources such as files contained within the deployment or process diagrams that were auto generated by the engine.

Wile the RepositoryService is rather about static information (ie. data that doesn't change, or at least not a lot), the **RuntimeService** is quite the opposite. It deals with starting new process instances of process definitions. As said above, a process definition defines the structure and behaviour of the different steps in a process. A process instance is one execution of such a process definition. For each process definition there typically are many instances running at the same time. The RuntimeService also is the service which is used to retrieve and store process variables. This is data which is specific to the given process instance and can be used by various constructs in the process (eg. an exclusive gateway often uses process variables to determine which path is chosen to continue the process). The Runtimeservice also allows to query on process instances and executions. Executions are a representation of the 'token' concept of BPMN 2.0. Basically an execution is a pointer pointing to where the process instance currently is. Lastly, the RuntimeService is used whenever a process instance is waiting for an external trigger and the process needs to be continued. A process instance can have various wait states and this service contains various operations to 'signal' the instance that the external trigger is received and the process instance can be continued.

Tasks that need to be performed by actual human users of the system are core to the process engine. Everything around tasks is grouped in the **TaskService**, such as

* Querying tasks assigned to users or groups.
* Creating new standalone tasks. These are tasks that are not related to a process instances.
* Manipulating to which user a task is assigned or which users are in some way involved with the task.
* Claiming and completing a task. Claiming means that someone decided to be the assigee for the task, meaning that this user will complete the task. Completing means 'doing the work of the tasks'. Typically this is filling in a form of sorts.

The **IdentityService** is pretty simple. It allows the management (creation, update, deletion, querying, ...) of groups and users. It is important to understand that the core engine actually doesn't do any checking on users at runtime. For example, a task could be assigned to any user, but the engine does not verify if that user is known to the system. This is because the engine can also used in conjunction with services such as LDAP, active directory, etc.

The **FormService** is an optional service. Meaning that the camunda engine can perfectly be used without it, without sacrificing any functionality. This service introduces the concept of a start form and a task form. A start form is a form that is shown to the user before the process instance is started, while a task form is the form that is displayed when a user wants to complete a form. You can define these forms in the BPMN 2.0 process definition. This service exposes this data in an easy way to work with. But again, this is optional as forms don't need to be embedded in the process definition.

The **HistoryService** exposes all historical data gathered by the engine. When executing processes, a lot of data can be kept by the engine (this is configurable) such as process instance start times, who did which tasks, how long it took to complete the tasks, which path was followed in each process instance, etc. This service exposes mainly query capabilities to access this data.

The **ManagementService** is typically not needed when coding custom application. It allows to retrieve information about the database tables and table metadata. Furthermore, it exposes query capabilities and management operations for jobs. Jobs are used in the engine for various things such as timers, asynchronous continuations, delayed suspension/activation, etc. Later on, these topics will be discussed in more detail.

<div class="alert alert-warning">
  <strong>Javadocs: </strong>
  <p>For more detailed information on the service operations and the engine API, see the <a href="http://docs.camunda.org/api-references/java/">javadocs</a>.</p>
</div>

<h3 id="query-api">Query API</h3>

To query data from the engine is possible in multiple ways:

* Java Query API: Fluent Java API to query engine entities (like ProcessInstances, Tasks, ...).
* REST Query API: REST API to query engine entities (like ProcessInstances, Tasks, ...).
* Native Queries: Provide own SQL queries to retrieve engine entities (like ProcessInstances, Tasks, ...) if the Query API lacks possibilities you need (e.g. OR conditions).
* Custom Queries: Use completly custom queries and an own MyBatis mapping to retrieve own value objects or join engine with domain data.
* SQL Queries: Use database SQL queries for use cases like Reporting.

The recommended way is to use on of the Query APIs.

The Java Query API allows to program completely typesafe queries with a fluent API You can add various conditions to your queries (all of which are applied together as a logical AND) and precisely one ordering. The following code shows an example:

    List<Task> tasks = taskService.createTaskQuery()
      .taskAssignee("kermit")
      .processVariableValueEquals("orderId", "0815")
      .orderByDueDate().asc()
      .list();

You can find more information on this in the <a href="http://docs.camunda.org/api-references/java/">javadocs</a>.

#### REST Query API

The Java Query API is exposed as REST service as well, see [REST documentation](<%= @docUrl('api-references/rest/') %>) for details.

#### Native Queries

Sometimes you need more powerful queries, e.g. queries using an OR operator or restrictions you can not express using the Query API. For these cases, we introduced native queries, which allow you to write your own SQL queries. The return type is defined by the Query object you use and the data is mapped into the correct objects, e.g. Task, ProcessInstance, Execution, etc.... Since the query will be fired at the database you have to use table and column names as they are defined in the database; this requires some knowledge about the internal data structure and it is recommended to use native queries with care. The table names can be retrieved via the API to keep the dependency as small as possible.

    List<Task> tasks = taskService.createNativeTaskQuery()
      .sql("SELECT count(\*) FROM " + managementService.getTableName(Task.class) + " T WHERE T.NAME_ = #{taskName}")
      .parameter("taskName", "gonzoTask")
      .list();

    long count = taskService.createNativeTaskQuery()
      .sql("SELECT count(\*) FROM " + managementService.getTableName(Task.class) + " T1, "
             + managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_")
      .count();

#### Custom Queries

For performance reasons it might sometimes be desirable not to query the engine objects but some own value or DTO objects collecting data from different tables - maybe including your own domain classes.

See <a href="https://app.camunda.com/confluence/display/foxUserGuide/Performance+Tuning+with+custom+Queries">Performance Tuning with custom Queries</a>.

#### SQL Queries

The table layout is pretty straightforward - we concentrated on making it easy to understand. Hence it is OK to do SQL queries for e.g. reporting use cases. Just make sure that you do not mess up the engine data by updating the tables without exactly knowing what you are doing.

See <a href="https://app.camunda.com/confluence/display/foxUserGuide/Reports+with+BIRT">Reports with BIRT</a> as example use case.

<h2 id="process-engine-concepts">Process Engine Concepts</h2>

This section explains some core process engine concepts that are used in both the process engine API and the internal process engine implementation. Understanding these fundamentals makes it easyier to use the process engine API.

<h3 id="process-engine-concepts-process-definitions">Process Definitions</h3>

A process definition defines the structure of a process. You could say that the process definition *is* the process. camunda BPM uses [BPMN 2.0](http://www.camunda.org/design/tutorial.html) as its primary modeling language for modeling process definitions.

<div class="alert alert-info">
  <strong>BPMN 2.0 Reference </strong>
  <p>camunda BPM comes with two BPMN 2.0 References:
  <ul>
    <li>The <a href="http://www.camunda.org/design/reference.html#!/reference">BPMN 2.0 Modeling Reference</a> introduces the fundamentals of BPMN 2.0 and helps you to get started modeling processes. (Make sure to read the <a href="http://www.camunda.org/design/tutorial.html">Tutorial</a> as well.)</li>
    <li>The <a href="/api-references/bpmn20/">BPMN 2.0 Implementation Reference</a> covers the implementation of the individual BPMN 2.0 constructs in camunda BPM. You should consult this reference if you want to implement and execute BPMN processes.</li>
  </p>
</div>

In camunda BPM you can deploy processes to the process engine in BPMN 2.0 XML format. The XML files are parsed and transformed into a process definition graph structure. This graph structure is executed by the process engine.

<h4 id="process-engine-concepts-process-definitions-query">Querying for Process Definitions</h4>

You can query for all deployed process definitions using the Java API and the `ProcessDefinitionQuery` made available through the `RepositoryService`. Example:

    List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery()
        .processDefinitionKey("invoice")
        .orderByProcessDefinitionVersion()
        .asc()
        .list();

The above query returns all deployed process definitions for the key `invoice` ordered by their `version` property.

You can also [query for process definitions using the REST API](/api-references/rest/#!/process-definition/get-query).

<h4 id="process-engine-concepts-process-definitions-key-version">Keys and Versions</h4>

The *key* of a process definition (`invoice` in the example above) is the logical identifier of the process. It is used throughout the API, most prominently for starting process instances ([see section on process instances](#process-engine-concepts-process-instances)). The key of a process definition is defined using the `id` property of the corresponding `<process ... >` element in the BPMN 2.0 XML file:

    <process id="invoice" name="invoice receipt" isExecutable="true">
      ...
    </process>

If you deploy multiple processes with the same key, they are treated as individual versions of the same process definition by the process engine.

#### Suspending Process Definitions ####

Suspending a process definition disables it temporarily in that it cannot be instantiated while it is suspended. The `RuntimeService` Java API can be used to suspend a process definition. Similarly, you can activate a process definition to undo this effect.

<h3 id="process-engine-concepts-process-instances">Process Instances</h3>

A process instance is an individual execution of a process definition. The relation of the process instance to the process definition is the same as the relation between *Object* and *Class* in Object Oriented Programming (the process instance playing the role of the object and the process definition playing the role of the class in this analogy).

The process engine is responsible for creating process instances and managing their state. If you start a process instance which contains a wait state, for example a [user task](/api-references/bpmn20/#!/tasks/user-task), the process engine must make sure that the state of the process instance is captured and stored inside a database until the wait state is left (the user task is completed).

<h4 id="process-engine-concepts-process-instances-start">Starting a Process Instance</h4>

The simplest way to start a process instance is by using the `startProcessInstanceByKey(...)` method offered by the RuntimeService:

    ProcessInstance instance = runtimeService.startProcessInstanceByKey("invoce");

You may optionally pass in a couple of variables:

    Map<String, Object> variables = new HashMap<String,Object>();
    variables.put("creditor", "Nice Pizza Inc.");
    ProcessInstance instance = runtimeService.startProcessInstanceByKey("invoce", variables);

Process variables are available to all tasks in a process instance and are automatically persisted to the database in case the process instance reaches a wait state.

It is also possible to [start a process instance using the REST API](/api-references/rest/#!/process-definition/post-start-process-instance).

<h4 id="process-engine-concepts-process-instances-query">Querying for Process Instances</h4>

You can query for all currently running process instances using the `ProcessInstanceQuery` offered by the `RuntimeService`:

    runtimeService.createProcessInstanceQuery()
        .processDefinitionKey("invoice")
        .variableValueEquals("creditor", "Nice Pizza Inc.")
        .list();

The above query would select all process instances for the `invoice` process where the `creditor` is `Nice Pizza Inc.`.

You can also [query for process instances using the REST API](/api-references/rest/#!/process-instance/get-query).

<h4 id="process-engine-concepts-process-instances-interact">Interacting with a Process Instance</h4>

Once you have performed a query for a particular process instance (or a list of process instances), you may want to interact with it. There are multiple possibilities to interact with a process instance, most prominently:

  * Triggering it (make it continue execution):
      * Through a [Message Event](/api-references/bpmn20/#!/events/message-events)
      * Through a [Signal Event](/api-references/bpmn20/#!/events/signal-events)
  * Canceling it:
      * Using the `RuntimeService.deleteProcessInstance(...)` method.

If your process uses User Task, you can also interact with the process instance using the TaskService API.

#### Suspending Process Instances ####

Suspending a process instance is helpful, if you want ensure that it is not executed any further. For example, if process variables are in an undesired state, you can suspend the instance and change the variables *safely*.

In detail, suspension means to disallow all actions that change *token* state (i.e. the activities that are currently executed) of the instance. For example, it is not possible to signal an event or complete a user task for a suspended process instance, as these actions will continue the process instance execution subsequently. Nevertheless, actions like setting or removing variables are still allowed, as they do not change token state.

Also, when suspending a process instance, all tasks belonging to it will be suspended. Therefore, it will no longer be possible to invoke actions that have effects on the task's *lifecycle* (i.e. user assignment, task delegation, task completion, ...). However, any actions not touching the lifecycle like setting variables or adding comments will still be allowed.

A process instance can be suspended by using the `suspendProcessInstanceById(...)` method of the `RuntimeService`. Similarly it can be reactivated again.

If you would like to suspend all process instances of a given process definition, you can use the method `suspendProcessDefinitionById(...)` of the`RepositoryService` and specify the `suspendProcessInstances` option.

<h3 id="process-engine-concepts-executions">Executions</h3>

If your process instance contains multiple execution paths (like for instance after a [parallel gateway](/api-references/bpmn20/#!/gateways/parallel-gateway)), you must be able to differentiate the currently active paths inside the process instance. In the following example, two user tasks *receive payment* and *ship order* can be active at the same time.

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/parallel-gw.png') %>"/></center>

Internally the process engine creates two concurrent executions inside the process instance, one for each concurrent path of execution. Executions are also created for scopes, for example if the process engine reaches a [Embedded Sub Process](/api-references/bpmn20/#!/subprocesses/embedded-subprocess) or in case of [Multi Instance](/api-references/bpmn20/#!/tasks/task-markers).

Executions are hierarchical and all executions inside a process instance span a tree, the process instance being the root-node in the tree. Note: the process instance itself is an execution.

#### Local Variables

Executions can have local variables. Local variables are only visible to the execution itself and its children but not to siblings of parents in the execution tree. Local variables are usually used if a part of the process works on some local data object or if an execution works on one item of a collection in case of multi instance.

In order to set a local variable on an execution, use the `setVariableLocal` method provided by the runtime service.

    runtimeService.setVariableLocal(name, value);

#### Querying for executions

You can query for executions using the `ExecutionQuery` offered by the `RuntimeService`:

    runtimeService.createProcessInstanceQuery()
        .processInstanceId(someId)
        .list();

The above query returns all executions for a given process instance.

You can also [query for executions using the REST API](/api-references/rest/#!/execution/get-query).

<h3 id="process-engine-concepts-activity-instances">Activity Instances</h3>

The activity instance concept is similar to the execution concept but takes a different perspective. While an execution can be imagined as a *token* moving through the process, an activity instance represents an individual instance of an activity (task, subprocess, ...). The concept of the activity instance is thus more *state-oriented*.

Activity instances also span a tree, following the scope structure provided by BPMN 2.0. Activities that are "on the same level of subprocess" (ie. part of the same scope, contained in the same subprocess) will have their activity instances at the same level in the tree

Examples:

  * Process with two parallel user tasks after parallel Gateway: in the activity instance tree you will see two activity instances below the root instance, one for each user task.
  * Process with two parallel Multi Instance user tasks after parallel Gateway: in the activity instance tree, all instances of both user tasks will be listed below the root activity instance. Reason: all activity instances are at the same level of subprocess.
  * Usertask inside embedded subprocess: the activity instance three will have 3 levels: the root instance representing the process instance itself, below it an activity instance representing the instance of the embedded subprocess, and below this one, the activity instance representing the usertask.

#### Retrieving an Activity Instance

Currently activity instances can only be retrieved for a process instance:

    ActivityInstance rootActivityInstance = runtimeService.getActivityInstance(processInstance.getProcessInstanceId());

You can <a href="/api-references/rest/#!/process-instance/get-activity-instances">retrieve the activity instance tree using the REST API</a> as well.

#### Identity & Uniqueness:
Each activity instance is assigned a unique Id. The id is persistent, if you invoke this method multiple times, the same activity instance ids will be returned for the same activity instances. (However, there might be different executions assigned, see below)

#### Relation to Executions
The Execution concept in the process engine is not completely aligned with the activity instance concept because the execution tree is in general not aligned with the activity / scope concept in BPMN. In general, there is a n-1 relationship between Executions and ActivityInstances, ie. at a given point in time, an activity instance can be linked to multiple executions. In addition, it is not guaranteed that the same execution that started a given activity instance will also end it. The process engine performs several internal optimizations concerning the compacting of the execution tree which might lead to executions being reordered and pruned. This can lead to situations where a given execution starts an activity instance but another execution ends it. Another special case is the process instance: if the process instance is executing a non-scope activity (for example a user task) below the process definition scope, it will be referenced by both the root activity instance and the user task activity instance.

Note: If you need to interpret the state of a process instance in terms of a BPMN process model, it is usually easier to use the activity instance tree as opposed to the execution tree.

<h2 id="database-configuration">Database configuration</h2>

There are two ways to configure the database that the camunda engine will use. The first option is to define the JDBC properties of the database:

* `jdbcUrl`: JDBC URL of the database.
* `jdbcDriver`: implementation of the driver for the specific database type.
* `jdbcUsername`: username to connect to the database.
* `jdbcPassword`: password to connect to the database.

Note that internally the engine uses <a href="http://www.mybatis.org/">Apache MyBatis</a> for persistence.

The data source that is constructed based on the provided JDBC properties will have the default MyBatis connection pool settings. The following attributes can optionally be set to tweak that connection pool (taken from the MyBatis documentation):

* `jdbcMaxActiveConnections`: The number of active connections that the connection pool at maximum at any time can contain. Default is 10.
* `jdbcMaxIdleConnections`: The number of idle connections that the connection pool at maximum at any time can contain.
* `jdbcMaxCheckoutTime`: The amount of time in milliseconds a connection can be 'checked out' from the connection pool before it is forcefully returned. Default is 20000 (20 seconds).
* `jdbcMaxWaitTime`: This is a low level setting that gives the pool a chance to print a log status and re-attempt the acquisition of a connection in the case that it's taking unusually long (to avoid failing silently forever if the pool is misconfigured) Default is 20000 (20 seconds).

Example database configuration:

    <property name="jdbcUrl" value="jdbc:h2:mem:camunda;DB_CLOSE_DELAY=1000" />
    <property name="jdbcDriver" value="org.h2.Driver" />
    <property name="jdbcUsername" value="sa" />
    <property name="jdbcPassword" value="" />

Alternatively, a `javax.sql.DataSource` implementation can be used (e.g. DBCP from Apache Commons):

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" >
      <property name="driverClassName" value="com.mysql.jdbc.Driver" />
      <property name="url" value="jdbc:mysql://localhost:3306/camunda" />
      <property name="username" value="camunda" />
      <property name="password" value="camunda" />
      <property name="defaultAutoCommit" value="false" />
    </bean>

    <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration">

        <property name="dataSource" ref="dataSource" />
        ...

Note that camunda does not ship with a library that allows to define such a data source. So you have to make sure that the libraries (e.g. from DBCP) are on your classpath.

The following properties can be set, regardless of whether you are using the JDBC or data source approach:

* `databaseType`: it's normally not necessary to specify this property as it is automatically analyzed from the database connection meta data. Should only be specified in case automatic detection fails. Possible values: {h2, mysql, oracle, postgres, mssql, db2}. This property is required when not using the default H2 database. This setting will determine which create/drop scripts and queries will be used. See the 'supported databases' section for an overview of which types are supported.</li>
* `databaseSchemaUpdate`: allows to set the strategy to handle the database schema on process engine boot and shutdown.
  * `false` (default): Checks the version of the DB schema against the library when the process engine is being created and throws an exception if the versions don't match.
  * `true`: Upon building the process engine, a check is performed and an update of the schema is performed if it is necessary. If the schema doesn't exist, it is created.
  * `create-drop`: Creates the schema when the process engine is being created and drops the schema when the process engine is being closed.

<div class="alert alert-warning">
  <strong>Supported Databases: </strong>
  <p>For information on supported databases please refer to <a href="https://app.camunda.com/confluence/display/foxUserGuide/Supported+environments">Supported Environments</a>.</p>
</div>

Here are some sample JDBC urls:

* h2: jdbc:h2:tcp://localhost/camunda
* mysql: jdbc:mysql://localhost:3306/camunda?autoReconnect=true
* oracle: jdbc:oracle:thin:@localhost:1521:xe
* postgres: jdbc:postgresql://localhost:5432/camunda
* db2: jdbc:db2://localhost:50000/camunda
* mssql: jdbc:sqlserver://localhost:1433/camunda

For more information on the database setup please refer to <a href="https://app.camunda.com/confluence/display/foxUserGuide/Database+Setup">Database Setup</a>

<h3 id="additional-database-schema-configuration">Additional database schema configuration</h3>

<h4 id="business-key">Business Key</h4>

Since the release of camunda-bpm Alpha 9, the unique constraint for the business key is removed in the runtime and history tables and the database schema create and drop scripts.
If you rely on the constraint, you can add it manually to your schema by issuing following sql statements:

  db2

    Runtime: create unique index ACT_UNIQ_RU_BUS_KEY on ACT_RU_EXECUTION(UNI_PROC_DEF_ID, UNI_BUSINESS_KEY);
    History: create unique index ACT_UNIQ_HI_BUS_KEY on ACT_HI_PROCINST(UNI_PROC_DEF_ID, UNI_BUSINESS_KEY);

  h2

    Runtime: alter table ACT_RU_EXECUTION add constraint ACT_UNIQ_RU_BUS_KEY unique(PROC_DEF_ID_, BUSINESS_KEY_);
    History: alter table ACT_HI_PROCINST add constraint ACT_UNIQ_HI_BUS_KEY unique(PROC_DEF_ID_, BUSINESS_KEY_);

  mssql

    Runtime: create unique index ACT_UNIQ_RU_BUS_KEY on ACT_RU_EXECUTION (PROC_DEF_ID_, BUSINESS_KEY_) where BUSINESS_KEY_ is not null;
    History: create unique index ACT_UNIQ_HI_BUS_KEY on ACT_HI_PROCINST (PROC_DEF_ID_, BUSINESS_KEY_) where BUSINESS_KEY_ is not null;

  mysql

    Runtime: alter table ACT_RU_EXECUTION add constraint ACT_UNIQ_RU_BUS_KEY UNIQUE (PROC_DEF_ID_, BUSINESS_KEY_);
    History: alter table ACT_HI_PROCINST add constraint ACT_UNIQ_HI_BUS_KEY UNIQUE (PROC_DEF_ID_, BUSINESS_KEY_);

  oracle

    Runtime: create unique index ACT_UNIQ_RU_BUS_KEY on ACT_RU_EXECUTION
             (case when BUSINESS_KEY_ is null then null else PROC_DEF_ID_ end,
             case when BUSINESS_KEY_ is null then null else BUSINESS_KEY_ end);
    History: create unique index ACT_UNIQ_HI_BUS_KEY on ACT_HI_PROCINST
             (case when BUSINESS_KEY_ is null then null else PROC_DEF_ID_ end,
             case when BUSINESS_KEY_ is null then null else BUSINESS_KEY_ end);

  postgres

    Runtime: alter table ACT_RU_EXECUTION add constraint ACT_UNIQ_RU_BUS_KEY UNIQUE (PROC_DEF_ID_, BUSINESS_KEY_);
    History: alter table ACT_HI_PROCINST add constraint ACT_UNIQ_HI_BUS_KEY UNIQUE (PROC_DEF_ID_, BUSINESS_KEY_);


<h2 id="database-table-names">Database table names explained</h2>

The table names all start with ACT. The second part is a two-character identification of the use case of the table. This use case will also roughly match the service API.

* ACT_RE_*: 'RE' stands for repository. Tables with this prefix contain 'static' information such as process definitions and process resources (images, rules, etc.).
* ACT_RU_*: 'RU' stands for runtime. These are the runtime tables, that contain the runtime data of process instances, user tasks, variables, jobs, etc. The engine only stores the runtime data during process instance execution, and removes the records when a process instance ends. This keeps the runtime tables small and fast.
* ACT_ID_*: 'ID' stands for identity. These tables contain identity information, such as users, groups, etc.
* ACT_HI_*: 'HI' stands for history. These are the tables that contain historic data, such as past process instances, variables, tasks, etc.
* ACT_GE_*: general data, which is used in various use cases.

<h2 id="history-configuration">History configuration</h2>

Customizing the configuration of <a href="https://app.camunda.com/confluence/display/foxUserGuide/History">history</a> is optional. This allows you to tweak settings that influence the history capabilities of the engine.

    <property name="history" value="audit" />

<h2 id="process-definition-cache">Process Definition Cache</h2>

All process definition are cached (after they're parsed) to avoid hitting the database every time a process definition is needed and because process definition data doesn't change.

<h2 id="transactions">Transactions in Processes</h2>

A process engine is a set of objects which are initialized and wait for threads that want to perform work in a particular process instance. It is essentially a passive component triggered only by these threads. For instance, if you have a web application allowing users to start a new process instance and a user clicks on the corresponding button, some thread from the application server's http-thread-pool will invoke the API method `runtimeService.startProcessInstanceByKey(...)`, thus *entering* the process engine and starting a new process instance.

On any such *external* trigger (i.e. start a process, complete a task, signal an execution), the engine runtime is going to advance in the process until it reaches wait states on each active path of execution. More concretely speaking it performs a depth-first traversal through the process graph and returns if it has reached wait states on every branch of execution. A wait state is a task which is performed *later*, which means that the engine persists the current execution and waits to be triggered again. For example in case of a user task, the external trigger on task completion causes the runtime to execute the next bit of the process until wait states are reached again (or the instance ends). In contrast to user tasks, a timer event is not triggered externally. Instead it is continued by an *internal* trigger. That is why the engine also needs an active component, the [job executor](#job-executor), which is able to fetch registered jobs and process them asynchronously.

<h3 id="transaction-boundaries">Transaction Boundaries</h3>

The transition from one such stable state to another stable state is always part of one transaction, meaning that it succeeds as a whole or is rolled back on any kind of exception occuring during its execution. This is illustrated in the following example:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/transactions-1.png') %>"/></center>

We see a segment of a BPMN process with a user task, a service task and a timer event. The timer event marks the next wait state. Completing the user task and validating the address is therefore part of the same unit of work, so it should succeed or fail atomically. That means that if the service task throws an exception we want to rollback the current transaction, such that the execution tracks back to the user task and the user task is still present in the database. This is also the default behavior of the process engine.

In **1**, an application or client thread completes the task. In that same thread the engine runtime is now executing the service task and advances until it reaches the wait state at the timer event (**2**). Then it returns the control to the caller (**3**) potentially committing the transaction (if it was started by the engine).

In some cases this behavior is not desired. Sometimes we need custom control over transaction boundaries in a process, in order to be able to scope logical units of work. Consider the following process fragment:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/transactions-2.png') %>"/></center>

This time we are completing the user task, generating an invoice and then send that invoice to the customer. This time the generation of the invoice is not part of the same unit of work so we do not want to rollback the completion of the usertask if generating an invoice fails. So what we want the engine to do is complete the user task (**1**), commit the transaction and return the control to the calling application (**2**).

Then we want to generate the invoice asynchronously, in a background thread. A pool of background threads is manged by the [job executor](#job-executor). It periodically checks the database for asynchronous *jobs*, i.e. units of work in the process runtime.

So behind the scenes, when we reach the *generate invoice* task, we are persisting a job in the database, queueing it for later execution. This job is then picked up by the job executor and executed (**3**). We are also giving the local job executor a little hint that there is a new job, to improve performance. In order to use this feature, we can use the `camunda:async="true"` extension in the BPMN 2.0 XML. So for example, the service task would look like this:

    <serviceTask id="service1" name="Generate Invoice" camunda:class="my.custom.Delegate" camunda:async="true" />

`camunda:async` can be specified on the following bpmn task types: `task`, `serviceTask`, `scriptTask`, `businessRuleTask`, `sendTask`, `receiveTask`, `userTask`, `subProcess` and `callActivity`. On a user task, receive task or other wait states, the additional async continuation allows us to execute the start execution listeners in a separate thread/transaction.

A start event may also be declared as asynchronous in the same way as above by the attribute `camunda:async="true"`. On instantiation, the process instance will be created and persisted in the database, but execution will be deferred. Also, execution listeners will not be invoked synchronously. This can be helpful in various situations such as [heterogeneous clusters](#job-execution-heterogeneous-clusters), when the execution listener class is not available on the node that instantiates the process.

<h2 id="job-executor">The Job Executor</h2>

A job is an explicit representation of a task to trigger process execution. A job is created whenever a wait state is reached during process execution that has to be triggered internally. This is the case when a timer event or a task marked for asynchronous execution (see [transaction boundaries](#transaction-boundaries)) is approached. The job executor has two responsibilities: job acquisition and job execution. The following diagram illustrates this:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/job-executor-basic-architecture.png') %>"/></center>

<h3 id="job-executor-activation">Job Executor Activation</h3>

By default, the JobExecutor is activated when the process engine boots. For unit testing scenarios it is cumbersome to work with this background component. Therefore the Java API offers to query for (`ManagementService.createJobQuery`) and execute jobs (`ManagementService.executeJob`) *by hand*, which allows to control job execution from within a unit test. To avoid interference with the job executor, it can be switched off.

Specify

    <property name="jobExecutorActivate" value="false" />

in the process engine configuration when you don't want the JobExecutor to be activated upon booting the process engine.

<h3 id="job-acquisition">Job Acquisition</h3>

Job acquisition is the process of retrieving jobs from the database that are to be executed next. Therefore jobs must be persisted to the database together with properties determining whether a job can be executed. For example, a job created for a timer event may not be executed before the defined time span has passed.

#### Persistency

Jobs are persisted to the database, in the ACT_RU_JOB table. This database table has the following columns (among others):

  ID_ | REV_ | LOCK_EXP_TIME_ | LOCK_OWNER_ | RETRIES_ | DUEDATE_

Job acquisition is concerned with polling this database table and locking jobs.

#### Acquirable Jobs

A job is acquirable, i.e. a candidate for execution, if

* it is due, meaning that the value in the DUEDATE&#95; column is in the past
* it is not locked, meaning that the value in the LOCK&#95;EXP&#95;TIME&#95; column is in the past
* its retries have not elapsed, meaning that the value in the RETRIES&#95; column is greater than zero.

In addition, the process engine has a concept of suspending a process definition and a process instance. A job is only acquirable if neither the corresponding process instance nor the corresponding process definition are suspended.

#### The two Phases of Job Acquisition

Job acquisition has two phases. In the first phase the job executor queries for a configurable amount of acquirable jobs. If at least one job can be found, it enters the second phase, locking the jobs. Locking is necessary in order to ensure that jobs are executed exactly once. In a clustered scenario, it is accustom to operate multiple job executor instances (one for each node) that all poll the same ACT&#95;RU&#95;JOB table. Locking a job ensures that it is only acquired by a single job executor instance. Locking a job means updating its values in the LOCK&#95;EXP&#95;TIME&#95; and LOCK&#95;OWNER_ columns. The LOCK&#95;EXP&#95;TIME&#95; column is updated with a timestamp signifying a date that lies in the future. The intuition behind this is that we want to lock the job until that date is reached. The LOCK&#95;OWNER&#95; column is updated with a value uniquely identifying the current job executor instance. In a clustered scenario this could be a node name uniquely identifying the current cluster node.

The situation where multiple job executor instances attempt to lock the same job concurrently is accounted for by using optimistic locking (see REV&#95; column).

After having locked a job, the job executor instance has effectively reserved a time slot for executing the job: once the date written to the LOCK&#95;EXP&#95;TIME&#95; column is reached it will be visible to job acquisition again. In order to execute the acquired jobs, they are passed to the acquired jobs queue.

<h3 id="job-execution">Job Execution</h3>

#### Thread Pool

Acquired jobs are executed by a thread pool. The thread pool consumes jobs from the acquired jobs queue. The acquired jobs queue is an in-memory queue with a fixed capacity. When an executor starts executing a job, it is first removed from the queue.

In the scenario of an embedded process engine, the default implementation for this thread pool is a `java.util.concurrent.ThreadPoolExecutor`. However, this is not allowed in Java EE environments. There we hook into the application server capabilities of thread management. See the platform-specific information in the [Runtime Container Integration](#runtime-container-integration) section on how this achieved.

#### Failed Jobs

Upon failure of job execution, e.g. if a service task invocation throws an exception, a job will be retried a number of times (by default 3). It is not immediately retried and added back to the acquisition queue, but the value of the RETRIES&#95; column is updated. The process engine thus performs bookkeeping for failed jobs. After updating the RETRIES&#95; column, the executor moves on to the next job. This means that the failed job will automatically be retried once the LOCK&#95;EXP&#95;TIME&#95; date is expired.

In real life it is useful to configure the retry strategy, i.e. the number of times a job is retried and when it is retried, so the LOCK&#95;EXP&#95;TIME&#95;. In the camunda engine, this can be configured as an extension element of a task in the BPMN 2.0 XML:

    <definitions ... xmlns:camunda="http://activiti.org/bpmn">
      ...
      <serviceTask id="failingServiceTask" camunda:async="true" camunda:class="org.camunda.engine.test.cmd.FailingDelegate">
        <extensionElements>
          <camunda:failedJobRetryTimeCycle>R5/PT5M</camunda:failedJobRetryTimeCycle>
        </extensionElements>
      </serviceTask>
      ...
    </definitions>

The configuration follows the [ISO_8601 standard for repeating time intervals](http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals). In the example, `R5/PT5M` means that the maximum number of retries is 5 (`R5`) and the delay of retry is 5 minutes (`PT5M`).

Similarly, the following example defines three retries after 5 seconds each for a boundary timer event:

    <boundaryEvent id="BoundaryEvent_1" name="Boundary event" attachedToRef="Freigebenden_zuordnen_143">
      <extensionElements>
        <camunda:failedJobRetryTimeCycle>R3/PT5S</camunda:failedJobRetryTimeCycle>
      </extensionElements>
      <outgoing>SequenceFlow_3</outgoing>
      <timerEventDefinition id="sid-ac5dcb4b-58e5-4c0c-b30a-a7009623769d">
        <timeDuration xsi:type="tFormalExpression" id="sid-772d5012-17c2-4ae4-a044-252006933a1a">PT10S</timeDuration>
      </timerEventDefinition>
    </boundaryEvent>

Recap: a retry may be required, if there are any failures during the transaction which follows the timer.

<h3 id="concurrent-job-execution">Concurrent Job Execution</h3>

The Job Executor makes sure that **jobs from a single process instance are never executed concurrently**. Why is this? Consider the following process definition:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/job-executor-exclusive-jobs.png') %>"/></center>

We have a parallel gateway followed by three service tasks which all perform an asynchronous continuation. As a result of this, three jobs are added to the database. Once such a job is present in the database it can be processed by the job executor. It acquires the jobs and delegates them to a thread pool of worker threads which actually process the jobs. This means that using an asynchronous continuation, you can distribute the work to this thread pool (and in a clustered scenario even across multiple thread pools in the cluster).

This is usually a good thing. However it also bears an inherent problem: consistency. Consider the parallel join after the service tasks. When the execution of a service task is completed, we arrive at the parallel join and need to decide whether to wait for the other executions or whether we can move forward. That means, for each branch arriving at the parallel join, we need to take a decision whether we can continue or whether we need to wait for one or more other executions from the other branches.

This requires synchronization between the branches of execution. The engine addresses this problem with optimistic locking. Whenever we take a decision based on data that might not be current (because another transaction might modify it before we commit), we make sure to increment the revision of the same database row in both transactions. This way, whichever transaction commits first wins and the other ones fail with an optimistic locking exception. This solves the problem in the case of the process discussed above: if multiple executions arrive at the parallel join concurrently, they all assume that they have to wait, increment the revision of their parent execution (the process instance) and then try to commit. Whichever execution is first will be able to commit and the other ones will fail with an optimistic locking exception. Since the executions are triggered by a job, the job executor will retry to perform the same job after waiting for a certain amount of time and hopefully this time pass the synchronizing gateway.

However, while this is a perfectly fine solution from the point of view of persistence and consistency, this might not always be desirable behavior at a higher level, especially if the execution has non-transactional side effects, which will not be rolled back by the failing transaction. For instance, if the *book concert tickets* service does not share the same transaction as the process engine, we might book multiple tickets if we retry the job. That is why jobs of the same process instance are processed *exclusively* by default.

#### Exclusive Jobs

An exclusive job cannot be performed at the same time as another exclusive job from the same process instance. Consider the process shown in the section above: if the jobs correpsonding to the service tasks are treated as exclusive, the job executor will make sure that they are not executed concurrently. Instead, it will ensure that whenever it acquires an exclusive job from a certain process instance, it also acquires all other exclusive jobs from the same process instance and delegates them to the same worker thread. This enforces sequential execution of the jobs.

**Exclusive Jobs are the default configuration**. All asynchronous continuations and timer events are thus exclusive by default. In addition, if you want a job to be non-exclusive, you can configure it as such using `camunda:exclusive="false"`. For example, the following service task would be asynchronous but non-exclusive.

  <serviceTask id="service" camunda:expression="${myService.performBooking(hotel, dates)}" camunda:async="true" camunda:exclusive="false" />

Is this a good solution? We had some people asking whether it was. Their concern was that it would prevent you from *doing things in parallel* and would thus be a performance problem. Again, two things have to be taken into consideration:

* It can be turned off if you are an expert and know what you are doing (and have understood this section). Other than that, it is more intuitive for most users if things like asynchronous continuations and timers just work.
* It is actually not a performance issue. Performance is an issue under heavy load. Heavy load means that all worker threads of the job executor are busy all the time. With exclusive jobs, the engine will simply distribute the load differently. Exclusive jobs means that jobs from a single process instance are performed by the same thread sequentially. But consider: you have more than one single process instance. And jobs from other process instances are delegated to other threads and executed concurrently. This means that with exclusive jobs the engine will not execute jobs from the same process instance concurrently but it will still execute multiple instances concurrently. From an overall throughput perspective this is desirable in most scenarios as it usually leads to individual instances being done more quickly.

<h3 id="job-executor-multiple-engines">The Job Executor and Multiple Process Engines</h3>

In the case of a single, application-embedded process engine, the job executor setup is the following:

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/job-executor-single-engine.png') %>" /></center>

There exists a single job table that the engine adds jobs to and the acquisition consumes from. Creating a second embedded engine would therefore create another acquisition thread and execution thread-pool.

In larger deployments however, this quickly leads to a poorly manageable situation. When running camunda BPM on Tomcat or an application server, the platform allows to declare multiple process engines shared by multiple process applications. With respect to job execution, one job acquisition may serve multiple job tables (and thus process engines) and a single thread-pool for execution may be used.

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/job-executor-multiple-engines.png') %>"/></center>

**This setup enables centralized monitoring of job acquisition and execution**.
See the platform-specific information in the [Runtime Container Integration](#runtime-container-integration) section on how the thread pooling is implemented on the different platforms.

Different job acquisitions can also be configured differently, e.g. to meet business requirements like SLAs. For example, the acquisition's timeout when no more executable jobs are present can be configured differently per acquisition.

To which job acquisition a process engine is assigned can be specified in the declaration of the engine, so either in the `processes.xml` deployment descriptor of a process application or in the camunda BPM platform descriptor. The following is an example configuration that declares a new engine and assigns it to the job acquisition named `default`, which is created when the platform is bootstrapped.

    <process-engine name="newEngine">
      <job-acquisition>default</job-acquisition>
      ...
    </process-engine>

Job acquisitions have to be declared in the BPM platform's deployment descriptor, see [the container-specific configuration options](#runtime-container-configuration).

<h3 id="cluster-setups">Cluster Setups</h3>

When running the camunda platform in a cluster, there is a distinction between *homogeneous* and *heterogeneous* setups. We define a cluster as a set of network nodes that all run the camunda BPM platform against the same database (at least for one engine on each node). In the *homogeneous* case, the same process applications (and thus custom classes like JavaDelegates) are deployed to all of the nodes, as depicted below.

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/homogeneous-cluster.png') %>"/></center>

In the *heterogeneous* case, this is not given, meaning that some process applications are deployed to only part of the nodes.

<center><img class="img-responsive" src="<%= @docUrl('guides/user-guide/assets/img/heterogeneous-cluster.png') %>"/></center>

<h4 id="job-execution-heterogeneous-clusters">Job Execution in Heterogeneous Clusters</h4>

A heterogeneous cluster setup as described above poses additional challenges to the job executor. Both platforms declare the same engine, i.e. they run against the same database. This means that jobs will be inserted into the same table. However, in the default configuration the job acquisition thread of node 1 will lock any executable jobs of that table and submit them to the local job execution pool. This means, jobs created in the context of process application B (so on node 2), may be executed on node 1 and vice versa. As the job execution may involve classes that are part of B's deployment, you are likely going to see a `ClassNotFoundExeception` or any of the likes.

To prevent the job acquisition on node 1 from picking jobs that *belong* to node 2, the process engine can be configured as *deployment aware*, by the setting following property in the process engine configuration:

    <process-engine name="default">
      ...
      <properties>
        <property name="jobExecutorDeploymentAware">true</property>
        ...
      </properties>
    </process-engine>

Now, the job acquisition thread on node 1 will only pick up jobs that belong to deployments made on that node, which solves the problem. Digging a little deeper, the acquisition will only pick up those jobs that belong to deployments that were *registered* with the engines it serves. Every deployment gets automatically registered. Additionally, one can explicitly register and unregister single deployments with an engine by using the `ManagementService` methods `registerDeploymentForJobExecutor(deploymentId)` and `unregisterDeploymentForJobExecutor(deploymentId)`. It also offers a method `getRegisteredDeployments()` to inspect the currently registered deployments.

As this is configurable on engine level, you can also work in a *mixed* setup, when some deployments are shared between all nodes and some are not. You can assign the globally shared process applications to an engine that is not deployment aware and the others to a deployment aware engine, probably both running against the same database. This way, jobs created in the context of the shared process applications will get executed on any cluster node, while the others only get executed on their respective nodes.

<h2 id="logging">Logging</h2>

We use <a href="http://docs.oracle.com/javase/6/docs/api/java/util/logging/package-summary.html">Java Logging</a> to avoid any third party logging requirements.

<h2 id="incidents">Incidents</h2>

Incidents are notable events that happen in the process engine. Such incidents usually indicate some kind of problem related to process execution. Examples of such incidents may be a failed job with elapsed retries (retries = 0), indicating that an execution is stuck and manual administrative action is necessary for repairing the process instance. Or the fact that a process instance has entered an error state which could be modelled as a BPMN Error Boundary event or a User Task explicitly marked as "error state". If such incidents arise, the process engine fires an internal event which can be handled by a configurable incident handler.

In the default configuration, the process engine writes incidents to the process engine database. You may then query the database for different types and kinds of incidents using the `IncidentQuery` exposed by the `RuntimeServie`:

    runtimeService.createIncidentQuery()
      .processDefinitionId("someDefinition")
      .list();

Incidents are stored in the AC_RU_INCIDENT database table.

If you want to customize the incident handling behavior, it is possible to replace the default incident handlers in the process engine configuration and provide custom implementations (see below).

<h3 id="incident-types">Incident Types</h3>

There are different types of incidents. Currently the process engine supports the following incidents:

  * **Failed Job**: this incident is raised when automatic retries for a Job (Timer or Asynchronous continuation) have elapsed. The incident indicates that the corresponding execution is stuck and will not continue automatically. Adminitrative action is necessary.
  The incident is resolved, when the job is executed manually or when the retries for the corresponding job are reset to a value > 0.

<h3 id="de-activating-incidents">(De-)Activating Incidents</h3>

The process engine allows you to configure on an incident type basis whether certain incidents should be raised or not.

The following properties are available in the `org.camunda.bpm.engine.ProcessEngineConfiguration` class:

  * `createIncidentOnFailedJobEnabled`: indicates whether Failed Job incidents should be raised.

<h3 id="implementing-custom-incident-handlers">Implementing custom Incident Handlers</h3>

Incident Handlers are responsible for handling incidents of a certain type (see Incident Types below).

An Incident Handler implements the following interface:

    public interface IncidentHandler {

      public String getIncidentHandlerType();

      public void handleIncident(String processDefinitionId, String activityId, String executionId, String configuration);

      public void resolveIncident(String processDefinitionId, String activityId, String executionId, String configuration);

    }

The `handleIncident` method is called when a new incident is created. The `resolveIncident` method is called when an incident is resolved. If you want to provide a custom incident handler implementation you can replace one or multiple incident handlers using the following method:

    org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl.setCustomIncidentHandlers(List<IncidentHandler>)

An example of a custom inciddent handler could be a handler which, in addtion to the default behavior also sends an email to an administrator.

<h2 id="bpmplatform-engine-plugins">Process Engine Plugins</h2>

The process engine configuration can be extended through process engine plugins. A process engine plugin is an extension to the [process engine configuration](#process-engine-configuration-bean).

A plugin must provide an implementation of the <a href="http://docs.camunda.org/api-references/java/org/camunda/bpm/engine/impl/cfg/ProcessEnginePlugin.html">ProcessEnginePlugin</a> interface.

<h3 id="bpmplatform-engine-plugins-configuration">Configuring Process Engine Plugins</h3>

Process engine plugins can be configured

* in the [BPM Platform Deployment Descriptors](/api-references/deployment-descriptors/) (bpm-platform.xml / processes.xml),
* in [JBoss Application Server 7 configuration file](#bpmplatform-container-jboss-process-engine-plugins) (standalone.xml / domain.xml)
* using Spring Beans XML,
* programatically.

The following is an example of how to configure a process engine plugin in bpm-platform.xml file:

    <?xml version="1.0" encoding="UTF-8"?>
    <bpm-platform xmlns="http://www.camunda.org/schema/1.0/BpmPlatform"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.camunda.org/schema/1.0/BpmPlatform http://www.camunda.org/schema/1.0/BpmPlatform ">

      <job-executor>
        <job-acquisition name="default" />
      </job-executor>

      <process-engine name="default">
        <job-acquisition>default</job-acquisition>
        <configuration>org.camunda.bpm.engine.impl.cfg.JtaProcessEngineConfiguration</configuration>
        <datasource>jdbc/ProcessEngine</datasource>

        <plugins>
          <plugin>
            <class>org.camunda.bpm.engine.MyCustomProcessEnginePlugin</class>
            <properties>
              <property name="boost">10</property>
              <property name="maxPerformance">true</property>
              <property name="actors">akka</property>
            </properties>
          </plugin>
        </plugins>
      </process-engine>

    </bpm-platform>

A process engine plugin class must be visible to the classloader which loads the process engine classes.

<h3 id="bpmplatform-engine-plugins-list">List of built-in Process Engine Plugins</h3>

The following is a list of built-in process engine plugins:

* [LDAP Identity Service Plugin](#bpmplatform-engine-identity-ldap)
* [Administrator Authorization Plugin](#bpmplatform-engine-authorization-plugin)
* [Process Application Event Listener Plugin](#bpmplatform-application-events)

<h2 id="bpmplatform-engine-identity">Identity Service</h2>

The identity service is an API abstraction over various User / Group repositories. The basic entities are

* User: a user identified by a unique Id
* Group: a group identified by a unique Id
* Membership: the relationship between users and groups

Example:

    User demoUser = processEngine.getIdentityService()
      .createUserQuery()
      .userId("demo")
      .singleResult();

camunda BPM distinguishes between read-only and writable user repositories. A read-only user repository provides read-only access to the underlying user / group database. A writable user repository allows write access to the user database which includes creating, updating and deleting users and groups.

In order to provide a custom identity provider implementation, the following interfaces can be implemented:

* [org.camunda.bpm.engine.impl.identity.ReadOnlyIdentityProvider](http://docs.camunda.org/api-references/java/org/camunda/bpm/engine/impl/identity/ReadOnlyIdentityProvider.html)
* [org.camunda.bpm.engine.impl.identity.WritableIdentityProvider](http://docs.camunda.org/api-references/java/org/camunda/bpm/engine/impl/identity/WritableIdentityProvider.html)

<h3 id="bpmplatform-engine-identity-database">The Database Identity Service</h3>

The database identity service uses the process engine database for managing users and groups. This is the default identity service implementation used if no alternative identity service implementation is provided.

The Database Identity Service implements both `ReadOnlyIdentityProvider` and `WritableIdentityProvider` providing full CRUD functionality in Users, Groups and Memberships.

<h3 id="bpmplatform-engine-identity-ldap">The LDAP Identity Service</h3>

The LDAP identity service provides read-only access to an LDAP-based user / group repository. The identity service provider is implemented as a [Process Engine Plugin](#bpmplatform-engine-plugins) and can be added to the process engine configuration. In that case it replaces the default Database Identity Service.

In order to use the LDAP identity service, the `camunda-identity-ldap.jar` library has to be added to the classloader of the process engine.

    <dependency>
      <groupId>org.camunda.bpm.identity</groupId>
      <artifactId>camunda-identity-ldap</artifactId>
      <version>${camunda.version}</version>
    </dependency>


The following is an example of how to configure the LDAP Identity Provider Plugin using Spring XML:

    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd">
      <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration">
        ...
        <property name="processEnginePlugins">
          <list>
            <ref bean="ldapIdentityProviderPlugin" />
          </list>
        </property>
      </bean>
      <bean id="ldapIdentityProviderPlugin" class="org.camunda.bpm.identity.impl.ldap.plugin.LdapIdentityProviderPlugin">
        <property name="serverUrl" value="ldap://localhost:3433/" />
        <property name="managerDn" value="uid=daniel,ou=office-berlin,o=camunda,c=org" />
        <property name="managerPassword" value="daniel" />
        <property name="baseDn" value="o=camunda,c=org" />

        <property name="userSearchBase" value="" />
        <property name="userSearchFilter" value="(objectclass=person)" />
        <property name="userIdAttribute" value="uid" />
        <property name="userFirstnameAttribute" value="cn" />
        <property name="userLastnameAttribute" value="sn" />
        <property name="userEmailAttribute" value="mail" />
        <property name="userPasswordAttribute" value="userpassword" />

        <property name="groupSearchBase" value="" />
        <property name="groupSearchFilter" value="(objectclass=groupOfNames)" />
        <property name="groupIdAttribute" value="ou" />
        <property name="groupNameAttribute" value="cn" />
        <property name="groupMemberAttribute" value="member" />
      </bean>
    </beans>

The following is an example of how to configure the LDAP Identity Provider Plugin in bpm-platform.xml / processes.xml:

    <process-engine name="default">
      <job-acquisition>default</job-acquisition>
      <configuration>org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration</configuration>
      <datasource>java:jdbc/ProcessEngine</datasource>

      <properties>...</properties>

      <plugins>
        <plugin>
          <class>org.camunda.bpm.identity.impl.ldap.plugin.LdapIdentityProviderPlugin</class>
          <properties>

            <property name="serverUrl">ldap://localhost:4334/</property>
            <property name="managerDn">uid=jonny,ou=office-berlin,o=camunda,c=org</property>
            <property name="managerPassword">s3cr3t</property>

            <property name="baseDn">o=camunda,c=org</property>

            <property name="userSearchBase"></property>
            <property name="userSearchFilter">(objectclass=person)</property>

            <property name="userIdAttribute">uid</property>
            <property name="userFirstnameAttribute">cn</property>
            <property name="userLastnameAttribute">sn</property>
            <property name="userEmailAttribute">mail</property>
            <property name="userPasswordAttribute">userpassword</property>

            <property name="groupSearchBase"></property>
            <property name="groupSearchFilter">(objectclass=groupOfNames)</property>
            <property name="groupIdAttribute">ou</property>
            <property name="groupNameAttribute">cn</property>

            <property name="groupMemberAttribute">member</property>

          </properties>
        </plugin>
      </plugins>

    </process-engine>

<div class="alert alert-info">
  <p>
    <strong>Administrator Authorization Plugin</strong>
    The LDAP Identity Provider Plugin is usually used in combination with the [Administrator Authorization Plugin](#bpmplatform-engine-authorization-plugin) which allows you to grant administrator authorizations for a particular LDAP User / Group.
  </p>
</div>

The LDAP Identity Provider provides the following configuration properties:

<table class="table table-striped">
  <tr>
    <th>Property</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`serverUrl`</td>
    <td>The url of the LDAP server to connect to.</td>
  </tr>
  <tr>
    <td>`managerDn`</td>
    <td>The absolute DN of the manager user of the LDAP directory.</td>
  </tr>
  <tr>
    <td>`managerPassword`</td>
    <td>The password of the manager user of the LDAP directory</td>
  </tr>
  <tr>
    <td>`baseDn`</td>
    <td>
      <p>The base DN: identifies the root of the LDAP directory. Is appended to all DN names composed for searching for users or groups.</p>
      <p><em>Example:</em> `o=camunda,c=org`</p>
    </td>
  </tr>
  <tr>
    <td>`userSearchBase`</td>
    <td>
      <p>Identifies the node in the LDAP tree under which the plugin should search for users. Must be relative to `baseDn`.</p>
      <p><em>Example:</em> `ou=employees`</p>
    </td>
  </tr>
  <tr>
    <td>`userSearchFilter`</td>
    <td>
      <p>LDAP query string used when searching for users. <em>Example:</em> `(objectclass=person)`</p>
    </td>
  </tr>
  <tr>
    <td>`userIdAttribute`</td>
    <td>
      <p>Name of the user Id property. <em>Example:</em> `uid`</p>
    </td>
  </tr>
  <tr>
    <td>`userFirstnameAttribute`</td>
    <td>
      <p>Name of the firstname property. <em>Example:</em> `cn`</p>
    </td>
  </tr>
  <tr>
    <td>`userLastnameAttribute`</td>
    <td>
      <p>Name of the lastname property. <em>Example:</em> `sn`</p>
    </td>
  </tr>
  <tr>
    <td>`userEmailAttribute`</td>
    <td>
      <p>Name of the email property. <em>Example:</em> `mail`</p>
    </td>
  </tr>
  <tr>
    <td>`userPasswordAttribute`</td>
    <td>
      <p>Name of the password property. <em>Example:</em> `userpassword`</p>
    </td>
  </tr>
  <tr>
    <td>`groupSearchBase`</td>
    <td>
      <p>Identifies the node in the LDAP tree under which the plugin should search for groups. Must be relative to `baseDn`.</p>
      <p><em>Example:</em> `ou=roles`</p>
    </td>
  </tr>
  <tr>
    <td>`groupSearchFilter`</td>
    <td>
      <p>LDAP query string used when searching for groups. <em>Example:</em> `(objectclass=groupOfNames)`</p>
    </td>
  </tr>
  <tr>
    <td>`groupIdAttribute`</td>
    <td>
      <p>Name of the group Id property. <em>Example:</em> `ou`</p>
    </td>
  </tr>
  <tr>
    <td>`groupNameAttribute`</td>
    <td>
      <p>Name of the group Name property. <em>Example:</em> `cn`</p>
    </td>
  </tr>
  <tr>
    <td>`groupTypeAttribute`</td>
    <td><p>Name of the group Type property. <em>Example:</em> `cn`</p></td>
  </tr>
  <tr>
    <td>`groupMemberAttribute`</td>
    <td>
      <p>Name of the member attribute. <em>Example:</em> `member`</p>
    </td>
  </tr>
  <tr>
    <td>`acceptUntrustedCertificates`</td>
    <td>
      <p>Accept of untrusted certificates if LDAP server uses Ssl. <strong>Warning:</strong> we strongly advise against using this property. Better install untrusted certificates to JDK key store.</p>
    </td>
  </tr>
  <tr>
    <td>`useSsl`</td>
    <td>
      <p>Set to true if LDAP connection uses SSL. <em>Default:</em> `false`</p>
    </td>
  </tr>
  <tr>
    <td>`initialContextFactory`</td>
    <td>
      <p>Value for the `java.naming.factory.initial` property. <em>Default:</em> `com.sun.jndi.ldap.LdapCtxFactory`</p>
    </td>
  </tr>
  <tr>
    <td>`securityAuthentication`</td>
    <td>
      <p>Value for the `java.naming.security.authentication` property. <em>Default:</em> `simple`</p>
    </td>
  </tr>
</table>

<h2 id="bpmplatform-engine-authorization">Authorization Service</h2>

camunda BPM provides a resource oriented authorization framework.

<strong>Authorizations</strong>
An Authorization assigns a set of Permissions to an identity to interact with a given Resource.

<em>Examples</em>

* User 'jonny' is authorized to start new instances of the 'invoice' process
* Group 'marketing' is not authorized to cancel process instances.
* Group 'marketing' is not allowed to use the tasklist application.
* Nobody is allowed to edit process variables in the cockpit application, except the distinct user 'admin'.

<strong>Identities</strong>
camunda BPM distinguished two types of identities: users and groups. Authorizations can either range over all users (userId = ANY), an individual User or a Group of users.

<strong>Permissions</strong>
A Permission defines the way an identity is allowed to interact with a certain resource. Examples of permissions are CREATE, READ, UPDATE, DELETE, ... See Permissions for a set of built-in permissions.

A single authorization object may assign multiple permissions to a single user and resource:

    authorization.addPermission(Permissions.READ);
    authorization.addPermission(Permissions.WRITE);
    authorization.addPermission(Permissions.DELETE);

On top of the built-in permissions, camunda BPM allows using custom permission types.

<strong>Resources</strong>
Resources are the entities the user interacts with. Examples of resources are GROUPS, USERS, process-definitions, process-instances, tasks ...

<div class="alert alert-info">
  <p>
    <strong>Built-In Resources</strong>
  </p>
  <p>
    The following resources are currently supported by the authorization framework:
    <ul>
      <li>Application (cockpit, tasklist, ...)</li>
      <li>Authorization</li>
      <li>Group</li>
      <li>Group Membership</li>
      <li>User</li>
    </ul>
  </p>
</div>

On top of the built-in resources, the camunda BPM framework supports defining custom resources. Authorization on custom resources will not be automatically performed by the framework but can be performed by a process application.

<strong>Authorization Type</strong>
There are three types of authorizations:

Global Authorizations (`AUTH_TYPE_GLOBAL`) range over all users and groups (`userId = ANY`) and are usually used for fixing the "base" permission for a resource.
Grant Authorizations (`AUTH_TYPE_GRANT`) range over users and groups and grant a set of permissions. Grant authorizations are commonly used for adding permissions to a user or group that the global authorization revokes.
Revoke Authorizations (`AUTH_TYPE_REVOKE`) range over users and groups and revoke a set of permissions. Revoke authorizations are commonly used for revoking permissions to a user or group the the global authorization grants.

<strong>Authorization Precedence</strong>
Authorizations may range over all users, an individual user or a group of users or they may apply to an individual resource instance or all instances of the same type (resourceId = ANY). The precedence is as follows:

* An authorization applying to an individual resource instance precedes over an authorization applying to all instances of the same resource type.
* An authorization for an individual user precedes over an authorization for a group.
* A Group authorization precedes over a GLOBAL authorization.
* A Group REVOKE authorization precedes over a Group GRANT authorization.

<h3 id="bpmplatform-engine-authorization-create">Creating an Authorization</h3>
An authorization is created between a user/group and a resource. It describes the user/group's permissions to access that resource. An authorization may express different permissions, such as the permission to READ, WRITE, DELETE the resource. (See Authorization for details).

In order to grant the permission to access a certain resource, an authorization object is created:

    Authorization auth = authorizationService.createNewAuthorization();

    // The authorization object can be configured either for a user or a group:
    auth.setUserId("john");
    //  -OR-
    auth.setGroupId("management");

    //and a resource:
    auth.setResource("processDefinition");
    auth.setResourceId("2313");

    // finally the permissions to access that resource can be assigned:
    auth.addPermission(Permissions.READ);

    // and the authorization object is saved:
    authorizationService.saveAuthorization(auth);

As a result, the given user or group will have permission to READ the referenced process definition.


<h3 id="bpmplatform-engine-authorization-plugin">The Administrator Authorization Plugin</h3>

camunda BPM has no explicit concept of "administrator". An administrator in camunda BPM is a user who has been granted all authorizations on all resources.

When downloading the camunda BPM distribution, the invoice example application creates a user with id `demo` and assigns administrator authorizations to this user. In addition, the [camunda Admin Web application](#tools-user-management-initial-user-setup) allows you to create an initial administrator user if no user is present in the database (when using the [Database Identity Service](#bpmplatform-engine-identity-database) or a custom implementation providing READ / WRITE access to the user repository).

This is not the case when using the [LDAP Identity Service](#bpmplatform-engine-identity-ldap). The LDAP idenitity service only has read access to the user repository and the "Create Initial User" dialog will not be displayed.

In this case you can use the *Administrator Authorization Plugin* for making sure administrator authorizations are created for a particular LDAP User or Group.

The following is an example of how to configure the Administrator Authorization Plugin in bpm-platform.xml / processes.xml:

    <process-engine name="default">
      ...
      <plugins>
        <plugin>
          <class>org.camunda.bpm.engine.impl.plugin.AdministratorAuthorizationPlugin</class>
          <properties>
            <property name="administratorUserName">admin</property>
          </properties>
        </plugin>
      </plugins>
    </process-engine>

The plugin will make sure that administrator authorizations (ALL permissions) are granted on all resources whenever the process engine is started.

<div class="alert alert-info">
  <p>
    <strong>Note</strong>
    It is not necessary to configure all LDAP users and groups which should have administrator authorization. It is usually enough to configure a single user and use that user to log into the webapplication and create additional authorizations using the User Interface.
  </p>
</div>

Complete list of configuration properties:

<table class="table table-striped">
  <tr>
    <th>Property</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`administratorUserName`</td>
    <td>The name of the administrator user. If this name is set to a non-null and non-empty value, the plugin will create user-level Administrator authorizations on all built-in resources.</td>
  </tr>
  <tr>
    <td>`administratorGroupName`</td>
    <td>The name of the administrator group. If this name is set to a non-null and non-empty value, the plugin will create group-level Administrator authorizations on all built-in resources.</td>
  </tr>
</table>